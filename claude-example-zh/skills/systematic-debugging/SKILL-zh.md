---
name: systematic-debugging
description: 四阶段调试方法论与根本原因分析。在调查 Bug、修复测试失败或排查意外行为时使用。强调必须在先找到根本原因之前不要应用任何修复。
---

# 系统性调试

## 核心原则

**没有根本原因调查就不要应用任何修复。**

永远不要应用仅针对症状的补丁来掩盖潜在问题。在尝试修复之前，理解为什么会失败。

## 四阶段框架

### 阶段 1：根本原因调查

在触摸任何代码之前：

1. **彻底阅读错误信息** - 每个词都很重要
2. **一致地重现问题** - 如果不能重现，就无法验证修复
3. **检查最近的更改** - 在开始失败之前改变了什么？
4. **收集诊断证据** - 日志、堆栈跟踪、状态转储
5. **跟踪数据流** - 跟踪调用链，找出错误值的来源

**根本原因跟踪技术：**
```
1. 观察症状 - 错误在哪里表现？
2. 找到直接原因 - 哪段代码直接产生错误？
3. 问"什么调用了这个？" - 向上映射调用链
4. 继续向上跟踪 - 沿着堆栈向后跟踪无效数据
5. 找到原始触发器 - 问题实际上从哪里开始？
```

**关键原则**：永远不要只在错误出现的地方修复问题——总是跟踪到原始触发器。

### 阶段 2：模式分析

1. **定位正常工作的示例** - 找到类似且正常工作的代码
2. **完全比较实现** - 不要只浏览
3. **识别差异** - 正常和失败代码之间有什么不同？
4. **理解依赖关系** - 这段代码依赖什么？

### 阶段 3：假设和测试

应用科学方法：

1. **形成一个清晰的假设** - "错误发生是因为 X"
2. **设计最小测试** - 一次只改变一个变量
3. **预测结果** - 如果假设正确，应该会发生什么？
4. **运行测试** - 执行并观察
5. **验证结果** - 行为是否如预期？
6. **迭代或继续** - 错误则 refine 假设，正确则实现

### 阶段 4：实现

1. **创建失败的测试用例** - 捕获 Bug 行为
2. **实现单个修复** - 解决根本原因，而非症状
3. **验证测试通过** - 确认修复有效
4. **运行完整测试套件** - 确保没有回归
5. **如果修复失败，停止** - 重新评估假设

**关键规则**：如果连续三次或更多修复失败，停止。这表明需要讨论，而不是更多补丁的架构问题。

## 危险信号 - 违反流程

如果你发现自己想以下这些，立即停止：

- "先快速修复，以后调查"
- "再尝试一次修复"（在多次失败后）
- "这应该有用"（不理解为什么）
- "让我试试..."（没有假设）
- "在我机器上能工作"（不调查差异）

## 更深层次问题的警告迹象

**连续修复在不同领域揭示新问题**表明架构问题：

- 停止打补丁
- 记录你发现的内容
- 继续讨论前与团队讨论
- 考虑设计是否需要重新思考

## 常见调试场景

### 测试失败

```
1. 完整阅读错误信息和堆栈跟踪
2. 识别哪个断言失败以及为什么
3. 检查测试设置 - 测试环境是否正确？
4. 检查测试数据 - 模拟装置/固定装置是否正确？
5. 追踪意外值的来源
```

### 运行时错误

```
1. 捕获完整堆栈跟踪
2. 识别抛出错误的行
3. 检查哪些值是 undefined/null
4. 向后跟踪找出错误值的来源
5. 在源头添加验证
```

### "以前是好的"

```
1. 使用 git bisect 找出破坏性的提交
2. 将更改与之前工作的版本比较
3. 识别什么假设改变了
4. 在假设违规的源头修复
```

### 间歇性失败

```
1. 寻找竞态条件
2. 检查共享可变状态
3. 检查异步操作顺序
4. 寻找时间依赖性
5. 添加确定性等待或适当的同步
```

## 调试清单

在声称修复 Bug 之前：

- [ ] 根本原因已识别并记录
- [ ] 假设已形成并测试
- [ ] 修复解决根本原因，而非症状
- [ ] 创建了重现 Bug 的失败测试
- [ ] 测试现在通过修复
- [ ] 完整测试套件通过
- [ ] 没有使用"快速修复"的合理化
- [ ] 修复是最小和专注的

## 成功指标

系统性调试实现约 95% 的一次修复成功率，而临时方法约为 40%。

你做得正确的迹象：
- 修复不会产生新的 Bug
- 你可以解释为什么发生了 Bug
- 类似的 Bug 不会复发
- 修复后代码更好，而不仅仅是"工作"

## 与其他技能的集成

- **testing-patterns**: 修复前创建重现 Bug 的测试